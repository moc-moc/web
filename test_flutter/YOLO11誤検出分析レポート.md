# YOLO11lモデル誤検出分析レポート

## 概要
YOLO11lモデルで多数の誤検出が発生し、それらの信頼度が非常に高い（0.995など）という問題が発生しています。

## ログから確認された問題点

### 1. 異常に高い信頼度
- 多くの検出で信頼度が0.995以上
- 例: `motorcycle (信頼度: 0.995)`, `toothbrush (信頼度: 0.995)`, `truck (信頼度: 0.995)`
- 実際には存在しないと思われる物体が多数検出されている

### 2. 不自然なバウンディングボックス
- ログ例: `bbox=[0.9064, 0.9221, 0.9351, 0.9495]` (正規化座標)
- しかし、`_mapToDetectionResults`では `toStringAsFixed(1)` で丸められて `[0.9, 0.9, 0.9, 0.9]` と表示
- 一部の検出で `bbox=[0.0, 0.0, 0.0, 0.0]` や `bbox=[1.0, 1.0, 1.0, 1.0]` など異常な値

### 3. 検出されるラベルの異常
- 実際には存在しないと思われる物体が多数検出:
  - `motorcycle`, `toothbrush`, `truck`, `vase`, `stop sign`, `sink`, `cat`, `cow`, `giraffe` など
- 検出数が異常に多い（89個、92個など）

## コード分析結果

### 問題1: YOLO11の出力形式の解釈が間違っている可能性

**現在のコード（`onnx_detection_service_web.dart` 718-722行目）:**
```dart
// YOLO11の出力形式: メモリレイアウトは [1, 8400, 84]
// データは [検出候補0の84特徴量, 検出候補1の84特徴量, ..., 検出候補8399の84特徴量] の順序でフラット化されている
// つまり、検出候補iのfeature jにアクセスするには: dataList[i * 84 + j]
```

**問題点:**
- YOLO11の実際の出力形式は `[1, 84, 8400]` の形状で、メモリレイアウトは `[batch, features, detections]` 形式の可能性が高い
- 現在のコードは `[1, 8400, 84]` 形式を想定しているが、実際は `[1, 84, 8400]` 形式の可能性がある
- これにより、バウンディングボックスとクラススコアの対応がずれている可能性がある

### 問題2: 信頼度スコアの解釈

**現在のコード（`onnx_detection_service_web.dart` 865-872行目）:**
```dart
for (int classIdx = 0; classIdx < 80; classIdx++) {
  final featureIdx = 4 + classIdx; // feature4がclass0、feature5がclass1、...
  final score = dataList[i * numFeaturesPerDetection + featureIdx] as double;
  if (score > maxScore) {
    maxScore = score;
    maxClassIdx = classIdx;
  }
}
```

**問題点:**
- YOLO11の出力は通常、**ロジット値（logit）**で、sigmoid関数を通す必要がある
- 現在のコードは生のロジット値をそのまま信頼度として使用している
- これにより、信頼度が異常に高く表示される可能性がある
- 正しくは: `confidence = 1 / (1 + exp(-logit))` でsigmoid関数を適用する必要がある

### 問題3: バウンディングボックスの座標形式

**現在のコード（`onnx_detection_service_web.dart` 856-859行目）:**
```dart
final x = dataList[i * numFeaturesPerDetection + 0] as double;
final y = dataList[i * numFeaturesPerDetection + 1] as double;
final w = dataList[i * numFeaturesPerDetection + 2] as double;
final h = dataList[i * numFeaturesPerDetection + 3] as double;
```

**問題点:**
- YOLO11の出力は通常、**正規化された座標（0-1の範囲）**で `[x_center, y_center, width, height]` 形式
- しかし、実際の出力形式が異なる可能性がある
- また、座標が画像サイズ（640x640）に対して正規化されているか確認が必要

### 問題4: データアクセスの順序

**ログから確認:**
- テンソル形状: `[1, 84, 8400]` と表示されている
- これは `[batch, features, detections]` 形式を意味する
- しかし、コードでは `[1, 8400, 84]` 形式を想定している

**正しいアクセス方法（推測）:**
```dart
// [1, 84, 8400] 形式の場合
// 検出候補iのfeature jにアクセス: dataList[j * 8400 + i]
// または: dataList[i * 84 + j] (転置されている場合)
```

## 推奨される修正方法

### 1. 出力テンソルの形状を確認
```dart
// テンソル形状を確認
final dims = outputTensor['dims'];
LogMk.logDebug('テンソル形状: $dims');
```

### 2. Sigmoid関数を適用
```dart
// 信頼度スコアにsigmoid関数を適用
double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

final score = sigmoid(dataList[i * numFeaturesPerDetection + featureIdx] as double);
```

### 3. データアクセスの順序を修正
```dart
// [1, 84, 8400] 形式の場合
// 検出候補iのfeature jにアクセス: dataList[j * 8400 + i]
for (int i = 0; i < numDetections; i++) {
  final x = dataList[0 * 8400 + i] as double;  // feature0 (x)
  final y = dataList[1 * 8400 + i] as double;  // feature1 (y)
  final w = dataList[2 * 8400 + i] as double;  // feature2 (w)
  final h = dataList[3 * 8400 + i] as double;  // feature3 (h)
  
  for (int classIdx = 0; classIdx < 80; classIdx++) {
    final featureIdx = 4 + classIdx;
    final logit = dataList[featureIdx * 8400 + i] as double;
    final score = sigmoid(logit);
    // ...
  }
}
```

### 4. バウンディングボックスの検証
```dart
// バウンディングボックスが有効な範囲内か確認
if (x < 0 || x > 1 || y < 0 || y > 1 || w <= 0 || h <= 0 || w > 1 || h > 1) {
  // 無効なバウンディングボックスをスキップ
  continue;
}
```

## 詳細な考察

### ログから確認された具体的な問題

#### 1. データアクセスの誤りによる影響

**ログ例:**
```
テンソル形状: [1, 84, 8400]
検出完了: 候補168個 → NMS後89個
```

**問題:**
- テンソル形状は `[1, 84, 8400]` と確認されている
- これは `[batch, features, detections]` 形式を意味する
- 現在のコードは `dataList[i * 84 + j]` でアクセスしているが、正しくは `dataList[j * 8400 + i]` であるべき
- この誤りにより、バウンディングボックスとクラススコアの対応が完全にずれている

**具体例:**
- 検出候補0のx座標を取得しようとしているが、実際には検出候補0のx座標ではなく、feature0の最初の値（検出候補0のx座標）を取得している
- しかし、データアクセスの順序が間違っているため、実際には別の検出候補のデータを取得している可能性が高い

#### 2. 信頼度が異常に高い理由

**ログ例:**
```
#1: motorcycle (信頼度: 0.995, bbox=[0.9064, 0.9221, 0.9351, 0.9495])
#2: toothbrush (信頼度: 0.995, bbox=[0.9637, 0.9757, 0.9859, 0.9951])
```

**問題:**
- YOLO11の出力は通常、ロジット値（logit）で、sigmoid関数を通す必要がある
- ロジット値が5.0の場合、sigmoid(5.0) ≈ 0.993 となる
- しかし、ロジット値が10.0の場合、sigmoid(10.0) ≈ 0.99995 となる
- 現在のコードはロジット値をそのまま信頼度として使用しているため、異常に高い値が表示されている可能性がある

**しかし、より深刻な問題:**
- データアクセスの順序が間違っているため、実際には別のクラスのスコアを取得している可能性が高い
- 例えば、motorcycleのスコアを取得しようとしているが、実際には別のクラス（例: person）のスコアを取得している
- これにより、誤検出が発生している

#### 3. バウンディングボックスの異常

**ログ例:**
```
#47: baseball glove (信頼度: 0.956, bbox=[0.0000, 0.0000, 0.0000, 0.0000])
#50: hair drier (信頼度: 0.947, bbox=[0.0000, 0.0000, 0.0000, 0.0000])
```

**問題:**
- バウンディングボックスが `[0.0, 0.0, 0.0, 0.0]` となっている検出が存在する
- これは明らかに無効なバウンディングボックスである
- データアクセスの順序が間違っているため、実際には別の検出候補のバウンディングボックスを取得している可能性が高い

#### 4. 検出数の異常

**ログ例:**
```
検出完了: 候補169個 → NMS後92個
```

**問題:**
- 通常、YOLO11の検出候補は8400個あるが、信頼度閾値（0.5）を超える候補が169個しかない
- これは、データアクセスの順序が間違っているため、実際には無効なデータを読み取っている可能性が高い
- また、NMS後も92個と多いが、これは誤検出が多いことを示している

### 根本原因の特定

**最も可能性が高い原因:**

1. **データアクセスの順序の誤り（最重要）**
   - テンソル形状 `[1, 84, 8400]` の場合、メモリレイアウトは行優先（row-major）形式
   - 検出候補iのfeature jにアクセス: `dataList[j * 8400 + i]`
   - 現在のコードは `dataList[i * 84 + j]` となっているため、完全に間違っている

2. **信頼度スコアの解釈の誤り**
   - YOLO11の出力はロジット値で、sigmoid関数を通す必要がある
   - しかし、データアクセスの順序が間違っているため、sigmoid関数を適用しても意味がない

3. **バウンディングボックスの検証不足**
   - 無効なバウンディングボックス（`[0.0, 0.0, 0.0, 0.0]` など）をフィルタリングしていない

## 結論

誤検出が多い主な原因は以下の3点と考えられます:

1. **データアクセスの順序の誤り（最重要）**: `[1, 84, 8400]` 形式のテンソルを `[1, 8400, 84]` 形式として解釈しているため、バウンディングボックスとクラススコアの対応が完全にずれている
2. **信頼度スコアの解釈の誤り**: ロジット値をそのまま信頼度として使用している（sigmoid関数が必要）
3. **バウンディングボックスの検証不足**: 無効なバウンディングボックスをフィルタリングしていない

**修正の優先順位:**
1. データアクセスの順序を修正（`dataList[j * 8400 + i]` に変更）
2. Sigmoid関数を適用
3. バウンディングボックスの検証を追加

これらの問題を修正することで、誤検出が大幅に減少し、信頼度も適切な値になることが期待されます。

